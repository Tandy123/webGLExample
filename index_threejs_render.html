<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - OBJLoader + MTLLoader</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Monospace;
				background-color: #000;
				color: #fff;
				margin: 0px;
				overflow: hidden;
			}
			#info {
				color: #fff;
				position: absolute;
				top: 10px;
				width: 100%;
				text-align: center;
				z-index: 100;
				display:block;
			}
			#info a, .button { color: #f00; font-weight: bold; text-decoration: underline; cursor: pointer }
		</style>
	</head>

	<body>
		<script src="libs/three.js"></script>
		<script src="libs/jquery-3.2.1.min.js"></script>
		<script src="libs/TrackballControls.js"></script>
		<script src="loaders/DDSLoader.js"></script>
		<script src="loaders/MTLLoader.js"></script>
		<script src="loaders/OBJLoaderWithIndex.js"></script>
		<script src="libs/Detector.js"></script>
		<script src="libs/stats.min.js"></script>
		
					<!-- Shaders -->
		<script type = "x-shader/x-vertex" id = "vertexshader">
			
			// switch on high precision floats
			#ifdef GL_ES
			precision highp float;
			#endif
																
			varying vec2 vUV;								
			varying vec3 vNormal;							
			varying vec3 vView;				
			varying vec3 vLightDir[2];
			
			//uniform vec3 lightsPos[2]; 
			vec3 lightsPos[2];
			vec4 pos;
														
			void main(void) {

				lightsPos[0] = vec3(40,   10, -10);
				lightsPos[1] = vec3(40,  -10,  10);
			
				gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.);
				pos	= gl_Position;			
				vNormal = vec3(modelMatrix * vec4(normal, 0.));											
				vView   = vec3(viewMatrix * modelMatrix * vec4(position, 1.));									
				vUV     = uv;
				vLightDir[0] = lightsPos[0] - pos.xyz;
				vLightDir[1] = lightsPos[1] - pos.xyz;
			}
		</script>
	
		<script type = "x-shader/x-fragment" id = "fragmentshader">
		
			#ifdef GL_ES 
			precision highp float;
			#endif
			
			precision mediump float;	
			
			uniform sampler2D sampler;	
			//uniform vec3 lights[6];// 3 vec4 for each light--- ambient,diffuse, specular color.
						
			varying vec2 vUV;										
			varying vec3 vNormal;									
			varying vec3 vView;	
			varying vec3 vLightDir[2];
									
			vec3 lights[6];							
			const int AMBIENT 	 = 0;
			const int DIFFUSE 	 = 1;
			const int SPECULAR 	 = 2;

		/*	const vec3 source_ambient_color  = vec3(0.9, 0.9, 0.9);		
			const vec3 source_diffuse_color  = vec3( 0.4588, 0.4549, 0.4470);		
			const vec3 source_specular_color =  vec3( 0.6, 0.6, 0.6 );//   vec3( 0.0784, 0.0784, 0.0784 );//
			const vec3 source_direction = vec3(1.0,0.0,0.0);	// reverse direction of the light...		
		*/
		
			const vec3 mat_ambient_color  = vec3(.805, .759, .736);		
			const vec3 mat_diffuse_color  = vec3(.45, .45, .45);		
			const vec3 mat_specular_color = vec3(.6, .6, .6);		
			const float mat_shininess = 200.;						
			
			void main(void) 
			{													
				vec3 color = vec3(texture2D(sampler, vUV));	
				vec3 fragColor = vec3(1.0);
				
				lights[AMBIENT]  = vec3(0.9, 0.9, 0.9);
				lights[DIFFUSE]  = vec3( 0.4588, 0.4549, 0.4470);
				lights[SPECULAR] = vec3( 0.6, 0.6, 0.6 );
			
				lights[3 + AMBIENT]  = vec3(0.9, 0.9, 0.9);
				lights[3 + DIFFUSE]  = vec3( 0.4588, 0.4549, 0.4470);
				lights[3 + SPECULAR] = vec3( 0.6, 0.6, 0.6 );	
				
				for(int i = 0; i < 2; i += 1 ){	
									
					vec3 source_direction = normalize(vLightDir[i]);
					vec3 source_ambient_color  	= lights[i * 3 + AMBIENT];
					vec3 source_diffuse_color  	= lights[i * 3 + DIFFUSE];
					vec3 source_specular_color 	= lights[i * 3 + SPECULAR];
					
					vec3 I_ambient = source_ambient_color * mat_ambient_color;											
					vec3 I_diffuse = source_diffuse_color * mat_diffuse_color * max(0., dot(vNormal, source_direction));	
					vec3 V = normalize(vView);																			
					vec3 R = reflect(source_direction, vNormal);														
					vec3 I_specular = source_specular_color * mat_specular_color * pow(max(dot(R,V),0.), mat_shininess);		
					vec3 I = I_ambient + I_diffuse + I_specular;
					
					fragColor =  0.5 * fragColor + I * color * 0.5;
					//fragColor =  fragColor + I * color;
					/*fragColor = vec3( max(0., dot(vNormal, source_direction)) );
					fragColor = source_diffuse_color * max(0., dot(vNormal, source_direction));
					fragColor = mat_diffuse_color * max(0., dot(vNormal, source_direction));*/
					fragColor = I_diffuse;
				}
				gl_FragColor = vec4(fragColor, 1.);		
			}
		
		</script>
		
		<script>

			var container, stats;

			var camera, scene, renderer;
			var trackballControls_pers, clock;
			var directionalLight, helper, help2, help3;

			var mouseX = 0, mouseY = 0;

			var windowHalfX = window.innerWidth / 2;
			var windowHalfY = window.innerHeight / 2;


			init();
			animate();


			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 2000 );
				//camera.position.z = 250;
				//camera.rotation.z = 50;
				camera.position.x = 50;
				camera.up.set( 0, 0, 1 );
				camera.lookAt(new THREE.Vector3(0,0,0));

				// trackball
				trackballControls_pers = new THREE.TrackballControls(camera);
				trackballControls_pers.rotateSpeed 	 = 1.0;
				trackballControls_pers.panSpeed 	 = 1.0;
				trackballControls_pers.staticMoving  = true;
				trackballControls_pers.target.set( 0, 0, 0 );
				
				clock = new THREE.Clock();
				
				// scene
				scene = new THREE.Scene();

			/*	var ambient = new THREE.AmbientLight( 0x444444 );
				scene.add( ambient );*/
			
				var dir1 = new THREE.Vector3( 1, 0, 0 );
				var dir2 = new THREE.Vector3( 0, 1, 0 );
				var dir3 = new THREE.Vector3( 0, 0, 1 );
				var dir4 = new THREE.Vector3( 1, 1, -1 );
				
				dir4 = dir4.normalize();
				
				var origin = new THREE.Vector3( 0, 0, 0 );
				var length = 5;
				
				var hex1 = 0xff0000;
				var hex2 = 0x00ff00;
				var hex3 = 0x0000ff;
				var hex4 = 0xffff00;
				
				var arrowHelper1 = new THREE.ArrowHelper( dir1, origin, length, hex1 );
				var arrowHelper2 = new THREE.ArrowHelper( dir2, origin, length, hex2 );
				var arrowHelper3 = new THREE.ArrowHelper( dir3, origin, length, hex3 );
				var arrowHelper4 = new THREE.ArrowHelper( dir4, origin, length * 2, hex4 );
				
				scene.add( arrowHelper1 );
				scene.add( arrowHelper2 );
				scene.add( arrowHelper3 );
				//scene.add( arrowHelper4 );
				
				
				//point light 
				var pointLight1 = new THREE.PointLight( 0xff0000, 1, 100 );
				var pointLight2 = new THREE.PointLight(0xff0000, 1, 100);
				
				pointLight1.position.set( 40,  10, -10 );
				pointLight2.position.set( 40, -10,  10 );
				
				var pointLightHelper1 = new THREE.PointLightHelper( pointLight1, 1 );
				var pointLightHelper2 = new THREE.PointLightHelper( pointLight2, 1 );
				
				scene.add(pointLightHelper1);
				scene.add(pointLightHelper2);
							
				// model
				var onProgress = function ( xhr ) {
					if ( xhr.lengthComputable ) {
						var percentComplete = xhr.loaded / xhr.total * 100;
						console.log( Math.round(percentComplete, 2) + '% downloaded' );
					}
				};

				var onError = function ( xhr ) { };

				THREE.Loader.Handlers.add( /\.dds$/i, new THREE.DDSLoader() );	
								
				var vShader = $('#vertexshader');
				var fShader = $('#fragmentshader');				
								
				var objLoader = new THREE.OBJLoader();	
				objLoader.setPath( 'ressources/U/' );
					objLoader.load( 'UL1.obj', function ( object ) {
					
						console.log(object.children[0].geometry.attributes);
						
						var shaderMaterialTooth = new THREE.ShaderMaterial({
									uniforms:   {
													sampler: {  value: new THREE.TextureLoader().load("ressources/U/test1.png") },												
												},
									shading: THREE.SmoothShading,
									vertexShader:   vShader.text(),
									fragmentShader: fShader.text()
								});
											
						object.children.forEach(function(mesh){
							mesh.material =  shaderMaterialTooth;//tooth_material;//
							mesh.geometry.computeFaceNormals();
							mesh.geometry.computeVertexNormals();
							mesh.geometry.dynamic = true;
						});
												
						scene.add( object );
						helper3 = new THREE.VertexNormalsHelper( object.children[0], 2, 0x00ff00 , 1 );
						//helper3 = new THREE.FaceNormalsHelper( object.children[0], 2, 0x00ff00 , 1 )
						//scene.add(helper3);

					}, onProgress, onError );

				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );
				renderer.setClearColor(new THREE.Color(0xeeeeee), 1.0);
				//renderer.setClearColor(new THREE.Color(0x000000), 1.0);				

				window.addEventListener( 'resize', onWindowResize, false );

			}

			function onWindowResize() {

				windowHalfX = window.innerWidth / 2;
				windowHalfY = window.innerHeight / 2;

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function onDocumentMouseMove( event ) {

				mouseX = ( event.clientX - windowHalfX ) / 2;
				mouseY = ( event.clientY - windowHalfY ) / 2;

			}

			//

			function animate() {

				requestAnimationFrame( animate );
				render();

			}

			function render() {

				var delta = clock.getDelta();
				trackballControls_pers.update(delta);
				renderer.render( scene, camera );

			}

		</script>
		
	</body>
</html>
